# Fire Simulator

## Overview
This project is a simple C++ application that take in incidents and stations in csv format and simulate dispatching of fire trucks to incidents.

## Folder Structure
```
fire_simulator
├── data
│   └── incidents.csv
│   └── stations.csv
├── src
│   └── folder/file.cpp
├── include
│   └── folder/file.h
├── CMakeLists.txt
├── .env
└── README.md
```

## Building the Project
Install the required packages:
> `gdb` debugging does not work on current macOS devices.
```bash
# For macOS
brew install cmake
brew install curl
brew install googletest
brew install nlohmann-json
brew install spdlog
brew install boost
brew install lp_solve
xcode-select --install

# For unix
sudo apt update
sudo apt install cmake g++ libcurl4-openssl-dev libgtest-dev gdb libboost-all-dev
sudo apt install nlohmann-json3-dev libspdlog-dev lp-solve
```

To build the project, navigate to the project directory and run the following command:

```bash
mkdir build
cd build
cmake ..
make -j4
```
or
```
./build.sh --clean --test
```

This will compile the source files and create an executable in the project's root folder.

## Running the Application
Modify the `pub.env` and change it to `.env`, update the paths and OSRM url.

1. Make sure that the `incidents.csv` look like this:
```csv
incident_id,lat,lon,incident_type,incident_level,datetime
0,36.005691,-86.73419,Road Closure,Low,2025-01-01 00:00:00
```
it should be 0th indexed without any missing indices in the middle.

2. and the `stations.csv` look like this:
```
OBJECTID,Facility Name,Address,City,State,Zip Code,GLOBALID,lon,lat
1,Station 39,1247 South Dickerson Rd,Goodlettsvi,TN,37072,eac3496b-ab7d-4f6a-ad14-bf5ada67676a,-86.73860485,36.29107537
```
it should be 0th  indexed without any missing indices in the middle.

3. A third file, `bounds.geojson` with a single polygon, defines the bounds of the system. If a point in incidents or stations is not within the boundary, it is ignored.
Right now, if you don't have a bounds.geojson it will not check any point.

4. After building the project, you can run the application with the following command:
```bash
# while inside build directory 
./src/fire_simulator
# just make sure the paths in the .env reflect where you are
```

## Cleaning Up
To remove the compiled files and clean the project directory, use the command:

```
make clean
```

## Development
Don't forget to create test cases. Place them inside `test/` and run `./test_simulator` after make.

```bash
# Run only nearest dispatch tests
./tests/unit_tests --gtest_filter="NearestDispatchTest.*"

# Run only location tests
./tests/unit_tests --gtest_filter="LocationTest.*"

# Running all tests, while in build dir
ctest
```

### Precomputing Travel times

Policies that rely on travel time matrices use `OSRM`. To save time, we query the service prior to execution. This then creates 2 binary files: 
1. `logs/distance_matrix.bin`
2. `logs/duration_matrix.bin`

### Dispatch Policies
Current behavior: incidents are served on a **first-come, first-serve** basis. it will only be considered resolved when all required apparatus is met.
Different dispatch policies affect which apparatus are sent to an incident.
* Nearest: Send the nearest fire trucks based on travel time.
* FireBeats: Send the fire trucks based on fire beats sequence.
    1. FireBeats_shapefile_05152025: Shape file of service zones.
    2. FIRE RUN CARDS OCT 2024: A collection of fire beat excel sheets for each service zone.
    Fire beats require preprocessing of these two files. The preprocessing code is included in `preprocess.ipynb`. This will generate a file `logs/beats.bin` that detail the different beats per service zone. And a file called `beats_shpfile.geojson` which are used during precmputing to identify the service zone an incident fall under.
    
### Summary of required files/services
1. `OSRM`: For generating routing solutions and travel time matrices. I have included a `Docker` container.
1. `incidents.csv`: Can be synthetically generated by `preprocess.ipynb` given a bounds.
    > Note index is internally tracked IDs, while id is what is written in the csv input. Same with the station index and ID.
2. `stations.csv`: Collected from [data.nashville.gov](https://data.nashville.gov/datasets/Nashville::fire-stations/explore?location=36.180107%2C-86.792213%2C10.04&showTable=true) but needs to be preprocessed into the correct WSG:84 projection.
3. `bounds.geojson`
4. `beats_shpfile.geojson`: Generated by `preprocess.ipynb`
5. `beats.bin`: Generated by `preprocess.ipynb`

### Summary of output files
1. `output.log`
2. `station_report.csv`: Mapping of stations to incidents. The same incidents can be mapped to different stations (if they all sent to the incident).
3. `incident_report.csv`: All metrics per incident, mostly timing related.

## TODO:
1. ~~Switch from vector of events to Priority Queue~~
2. ~~Clean up incident and station, remove function calls inside, put in a separate standalone function file.~~
3. ~~Clean up activeIncidents_, it should just be a priority queue (or even just a queue?)~~
4. Change incidents so no 2 incidents have the same time (have at least a second of difference).
5. ~~Create a separate map of incidents. that i just look up O(1) when i need information about the incident. dont add them in the event.~~
6. Maybe categorize medic as a :moving" fire Stations